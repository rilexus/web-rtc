{"ast":null,"code":"import { socket } from \"../../socket/socket\";\n\nclass EventListenerContainer {\n  constructor() {\n    this.listeners = {};\n  }\n\n  add(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [callback];\n      return;\n    }\n\n    this.listeners[event].push(callback);\n  }\n\n  remove(event, listener) {\n    if (this.listeners[event]) {\n      this.listeners[event] = this.listeners[event].filter(c => c !== listener);\n    }\n  }\n\n  getEventListeners(event) {\n    if (this.listeners[event]) {\n      return this.listeners[event];\n    }\n\n    return [];\n  }\n\n  getEventListener(event, callback) {\n    if (this.listeners[event]) {\n      return this.listeners[event].find(c => c === callback);\n    }\n\n    return;\n  }\n\n}\n\nclass EventEmitter {\n  constructor() {\n    this.events = void 0;\n    this.events = new EventListenerContainer();\n  }\n\n  addEventListener(event, callback) {\n    this.events.add(event, callback);\n  }\n\n  removeEventListener(event, listener) {\n    this.events.remove(event, listener);\n  }\n\n  on(event, callback) {\n    this.addEventListener(event, callback);\n  }\n\n  emit(event, ...args) {\n    this.events.getEventListeners(event).forEach(listener => {\n      if (typeof listener === \"function\") {\n        listener(...args);\n      }\n    });\n  }\n\n}\n\nclass WebRTC {\n  constructor(config) {\n    this.peerConnection = void 0;\n    this.eventEmitter = new EventEmitter();\n    this.peerConnection = new RTCPeerConnection(config);\n    this.peerConnection.ontrack = this.emitCall;\n    socket.on(\"onicecandidate\", ({\n      candidate\n    }) => {\n      console.log(\"got candidate: \", {\n        candidate\n      });\n      this.peerConnection.addIceCandidate(candidate);\n    });\n    socket.on(\"video:answer\", async ({\n      answer,\n      to,\n      from\n    }) => {\n      console.log(\"got answer: \", {\n        answer,\n        to,\n        from\n      });\n      await this.peerConnection.setRemoteDescription(answer);\n    });\n    socket.on(\"video:offer\", async ({\n      offer,\n      to,\n      from\n    }) => {\n      console.log(\"got offer: \", {\n        offer,\n        to,\n        from\n      });\n      await this.acceptOffer({\n        offer,\n        to,\n        from\n      });\n    });\n  }\n\n  async acceptOffer({\n    offer,\n    from,\n    to\n  }) {\n    console.log(\"accept offer: \", {\n      offer,\n      to,\n      from\n    });\n    await this.setOffer(offer);\n    const answer = this.createAnswer();\n    await this.setAnswer(answer);\n    this.emitAnswer(answer, from, to);\n  }\n\n  async createAnswer() {\n    return await this.peerConnection.createAnswer();\n  }\n\n  emitAnswer(answer, from, to) {\n    console.log(\"sending answer: \", {\n      answer,\n      to: from,\n      from: to\n    });\n    socket.emit(\"video:answer\", {\n      answer,\n      to: from,\n      from: to\n    });\n  }\n\n  async setAnswer(answer) {\n    return this.peerConnection.setLocalDescription(answer);\n  }\n\n  async setOffer(offer) {\n    return this.peerConnection.setRemoteDescription(offer);\n  }\n\n  emitCall(streams) {\n    this.eventEmitter.emit('call', streams);\n  }\n\n  emitVideoOffer(offer, from, to) {\n    console.log(\"sending offer: \", {\n      offer,\n      to,\n      from\n    });\n    socket.emit(\"video:offer\", {\n      offer,\n      from,\n      to\n    });\n  }\n\n  on(event, callback) {\n    this.eventEmitter.addEventListener(event, callback);\n  }\n\n  async call(to, from) {\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n    this.emitVideoOffer(offer, from, to);\n\n    this.peerConnection.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        console.log(\"sending candidate: \", {\n          candidate\n        });\n        socket.emit(\"onicecandidate\", {\n          candidate,\n          to,\n          from\n        });\n      }\n    };\n  }\n\n}\n\nexport { WebRTC };","map":{"version":3,"sources":["/Users/stanislavpanchenko/Documents/development/web-rtc/web-rtc-client/src/pages/chat/WebRTC.ts"],"names":["socket","EventListenerContainer","listeners","add","event","callback","push","remove","listener","filter","c","getEventListeners","getEventListener","find","EventEmitter","constructor","events","addEventListener","removeEventListener","on","emit","args","forEach","WebRTC","config","peerConnection","eventEmitter","RTCPeerConnection","ontrack","emitCall","candidate","console","log","addIceCandidate","answer","to","from","setRemoteDescription","offer","acceptOffer","setOffer","createAnswer","setAnswer","emitAnswer","setLocalDescription","streams","emitVideoOffer","call","createOffer","onicecandidate"],"mappings":"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","sourcesContent":["import {socket} from \"../../socket/socket\";\n\ntype Callback = (...args: any)=>void\n\nclass EventListenerContainer {\n  listeners:{[event: string]: Callback[]} = {}\n  add(event: string, callback:Callback): void {\n    if (!this.listeners[event]){\n      this.listeners[event] = [callback]\n      return\n    }\n    this.listeners[event].push(callback)\n  }\n  remove(event:string, listener: Callback){\n    if (this.listeners[event]){\n      this.listeners[event] = this.listeners[event].filter(c => c !== listener)\n    }\n  }\n\n  getEventListeners(event: string): Callback[] {\n    if (this.listeners[event]){\n      return this.listeners[event]\n    }\n    return  []\n  }\n\n  getEventListener(event: string, callback: Callback): Callback | undefined {\n    if (this.listeners[event]){\n      return this.listeners[event].find(c => c === callback)\n    }\n    return\n  }\n\n}\n\nclass EventEmitter {\n  events: EventListenerContainer\n  constructor() {\n    this.events = new EventListenerContainer()\n  }\n\n  addEventListener(event: string, callback: Callback): void {\n    this.events.add(event, callback)\n  }\n\n  removeEventListener(event: string, listener: Callback): void {\n    this.events.remove(event, listener)\n  }\n\n  on(event:string, callback: (...args: any)=>void):void {\n    this.addEventListener(event,callback)\n  }\n\n  emit(event:string, ...args: any): void {\n    this.events.getEventListeners(event).forEach((listener) => {\n      if (typeof listener === \"function\"){\n        listener(...args)\n      }\n    })\n  }\n}\n\ntype RTCPeerConnectionConfig = {\n  iceServers: { urls: string }[];\n};\nclass WebRTC {\n  peerConnection;\n  eventEmitter = new EventEmitter()\n  constructor(config: RTCPeerConnectionConfig) {\n    this.peerConnection = new RTCPeerConnection(config);\n\n    this.peerConnection.ontrack = this.emitCall\n\n\n    socket.on(\"onicecandidate\", ({ candidate }: any) => {\n      console.log(\"got candidate: \", { candidate });\n      this.peerConnection.addIceCandidate(candidate);\n    });\n\n    socket.on(\"video:answer\", async ({ answer, to, from }: any) => {\n      console.log(\"got answer: \", { answer, to, from });\n      await this.peerConnection.setRemoteDescription(answer);\n    });\n\n    socket.on(\"video:offer\", async ({ offer, to, from }: any) => {\n      console.log(\"got offer: \", { offer, to, from });\n      await this.acceptOffer({offer,to,from})\n    });\n  }\n\n  private async acceptOffer({offer, from, to}: {offer: any, from: string, to: string}){\n    console.log(\"accept offer: \", { offer, to, from });\n    await this.setOffer(offer)\n    const answer = this.createAnswer()\n    await this.setAnswer(answer)\n    this.emitAnswer(answer, from, to)\n  }\n\n  private async createAnswer() {\n    return await this.peerConnection.createAnswer();\n  }\n\n  private emitAnswer(answer: any, from:string, to:string){\n    console.log(\"sending answer: \", { answer, to: from, from: to });\n    socket.emit(\"video:answer\", { answer, to: from, from: to });\n  }\n  private async setAnswer(answer: any){\n    return  this.peerConnection.setLocalDescription(answer);\n  }\n  private async setOffer(offer: any){\n    return this.peerConnection.setRemoteDescription(offer);\n  }\n\n  private emitCall (streams: any): void{\n    this.eventEmitter.emit('call', streams)\n  }\n\n  private emitVideoOffer (offer: any, from: string, to: string){\n    console.log(\"sending offer: \", { offer, to, from });\n    socket.emit(\"video:offer\", { offer, from, to });\n  };\n\n  on(event: string, callback: Callback){\n    this.eventEmitter.addEventListener(event, callback)\n  }\n\n  async call(to: string, from: string) {\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n\n    this.emitVideoOffer(offer, from, to);\n\n\n    this.peerConnection.onicecandidate = ({ candidate }: any) => {\n      if (candidate) {\n        console.log(\"sending candidate: \", { candidate });\n        socket.emit(\"onicecandidate\", {\n          candidate,\n          to,\n          from,\n        });\n      }\n    };\n\n  }\n}\n\nexport { WebRTC };\nexport type { RTCPeerConnectionConfig };\n"]},"metadata":{},"sourceType":"module"}